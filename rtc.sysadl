Model SysADLModel ; package RTCTypes { value type Temperature { dimension = Temperature } value type FahrenheitTemperature extends Temperature { unit = Farenheit dimension = Temperature } value type CelsiusTemperature extends Temperature { unit = Celsius dimension = Temperature } dimension Temperature enum Command { On , Off } datatype Commands { attributes : heater : Command ; cooler : Command ; } unit Farenheit unit Celsius dimension Temperature port def FTemperatureOPT { flow out FahrenheitTemperature } port def CTemperatureOPT { flow out CelsiusTemperature } port def CTemperatureIPT { flow in CelsiusTemperature } value type Boolean { } } package RTCComponents { import RTCPorts ; import RTCConnectors ;
	component def RoomTemperatureControllerCP { ports : localTemp1 : CTemperatureIPT ; detected : PresenceIPT ; heating : CommandOPT ; cooling : CommandOPT ; configuration { components : PresenceSensorCP : PresenceSensorCP { using ports : detected : PresenceOPT ; } UserInterfaceCP : UserInterfaceCP { using ports : desired : CTemperatureOPT ; } TemperatureSensorCP : TemperatureSensorCP { using ports : current : FTemperatureOPT ; } TemperatureSensorCP : TemperatureSensorCP { using ports : current : FTemperatureOPT ; } CoolerCP : CoolerCP { using ports : controller : CommandIPT ; } HeaterCP : HeaterCP { using ports : controller : CommandIPT ; } PresenceCheckerCP : PresenceCheckerCP ; CommanderCP : CommanderCP ; TemperatureMonitorCP : TemperatureMonitorCP ; } }
	component def CoolerCP { ports : controller : CommandIPT ; }
	component def HeaterCP { ports : controller : CommandIPT ; }
	component def CommanderCP { }
	component def TemperatureSensorCP { ports : current : FTemperatureOPT ; }
	component def TemperatureMonitorCP { }
	component def PresenceCheckerCP { }
	component def UserInterfaceCP { ports : desired : CTemperatureOPT ; }
	component def PresenceSensorCP { ports : detected : PresenceOPT ; } } Requirement ControlRoomTemperatureFR ( 1 ) { text = "The controller must be capable to maintain the temperature in the room" satisfied by RTCComponents.RoomTemperatureControllerCP ; Requirement CommandHeaterAndCoolerFR ( 1.3 ) { text = "The controller must set the appropriate command to turn the heater or the cooler on in order to increase or decrease temperature" satisfied by RTCComponents.CommanderCP ; } Requirement MonitorTemperatureFR ( 1.1 ) { text = "The controller must receive data from all local temperature sensors and calculate the average temperature" } Requirement DefineTemperatureFR ( 1.2 ) { text = "The controller must define the target temperature considering the presence of the user and the desired temperature" } } Requirement SetDesiredTemperatureFR ( 1.5 ) { text = "The System must allow the user set the desired temperature in Celsius" satisfied by RTCComponents.UserInterfaceCP ; derive ControlRoomTemperatureFR.DefineTemperatureFR ; } Requirement VerifyPresenceFR ( 1.6 ) { text = "The controller must receive data from a presence sensor to verify if there is someone in the room" satisfied by RTCComponents.PresenceSensorCP ; derive ControlRoomTemperatureFR.DefineTemperatureFR ; } Requirement DecideTargetTemperatureFR ( 1.7 ) { text = "The controller must maintain the desired temperature if there is a person in the room or it must set temperature to 22 Celsiu when there is nobody in the room" satisfied by RTCComponents.PresenceCheckerCP , RTCComponents.TemperatureMonitorCP ; derive ControlRoomTemperatureFR.DefineTemperatureFR ; } Requirement ProvideLocalTemperatureFR ( 1.4 ) { text = "The system shall use connected sensors to get the temperature of room" satisfied by RTCComponents.TemperatureSensorCP ; derive ControlRoomTemperatureFR.MonitorTemperatureFR ; } Requirement DecreaseTemperature ( 1.9 ) { text = "The controller must turn the cooler on and the heater off to decrease temperature" satisfied by RTCComponents.CoolerCP ; derive ControlRoomTemperatureFR.CommandHeaterAndCoolerFR ; } Requirement IncreaseTemperatureFR ( 1.8 ) { text = "The controller must turn the heater on and the cooler off to increase temperature" satisfied by RTCComponents.HeaterCP ; derive ControlRoomTemperatureFR.CommandHeaterAndCoolerFR ; } package RTCPorts { import RTCTypes ; port def FTemperatureIPT { flow in FahrenheitTemperature } port def FTemperatureOPT { flow out FahrenheitTemperature } port def CommandIPT { flow in Command } port def CommandOPT { flow out Command } port def PresenceIPT { flow in Boolean } port def PresenceOPT { flow out Boolean } port def CTemperatureIPT { flow in CelsiusTemperature } port def CTemperatureOPT { flow out CelsiusTemperature } } package RTCConnectors { import RTCPorts ; connector def FarenheitToCelsiusCN { participants : ~ source : FTemperatureOPT ; ~ destination : CTemperatureIPT ; } connector def CTemperatureCN { participants : ~ source : CTemperatureOPT ; ~ destination : CTemperatureIPT ; } connector def DetectPresenceCN { participants : ~ source : PresenceOPT ; ~ destination : PresenceIPT ; } connector def ControlCommandCN { participants : ~ source : CommandOPT ; ~ destination : CommandIPT ; } }